//! # LLcraft VM Interpreter
//!
//! Executes programs generated by the LLM. The interpreter:
//! - Manages memory (pages) and stack
//! - Executes opcodes sequentially
//! - Handles control flow (labels, jumps, branches)
//! - Invokes syscalls for external operations
//! - Calls the LLM for INFER/PLAN/REFLECT operations
//! - Manages session persistence for context efficiency

use crate::error::{self, Result};
use crate::memory::Memory;
use crate::opcode::{Opcode, Program, LogLevel};
use crate::schema::ExecutionStep;
use crate::session::{Session, SessionManager, SessionStatus};
use crate::stack::Stack;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Maximum execution steps (prevents infinite loops)
pub const MAX_STEPS: usize = 10_000;

/// Result of program execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExecutionResult {
    /// Program completed successfully with a result
    Complete(serde_json::Value),
    /// Program failed with an error
    Failed(String),
    /// Program needs LLM input (INFER/PLAN/REFLECT)
    NeedsLlm(LlmRequest),
    /// Program exceeded max steps
    StepLimitExceeded,
}

/// A request for LLM input during execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LlmRequest {
    /// Type of request
    pub request_type: LlmRequestType,
    /// The prompt to send
    pub prompt: String,
    /// Context pages to include
    pub context_pages: Vec<String>,
    /// Where to store the result (empty for Inject - code goes into program)
    pub store_to: String,
    /// Current execution state for continuation
    pub execution_state: ExecutionState,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LlmRequestType {
    Infer,
    Plan,
    Reflect { include_trace: bool },
    /// JIT injection - LLM should return opcodes to insert
    Inject { include_trace: bool, include_memory: bool },
    /// Batched inference - run multiple prompts concurrently
    InferBatch {
        prompts: Vec<String>,
        context: Vec<serde_json::Value>,
        store_prefix: String,
        store_combined: Option<String>,
        params: crate::opcode::InferParams,
    },
}

/// Serializable execution state for pause/resume
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionState {
    /// Current program counter
    pub pc: usize,
    /// The program being executed
    pub program: Program,
    /// Memory pages
    pub memory: Memory,
    /// Stack
    pub stack: Stack,
    /// Registers
    pub registers: HashMap<String, serde_json::Value>,
    /// Execution trace
    pub trace: Vec<ExecutionStep>,
    /// Step count
    pub steps: usize,
}

/// Syscall handler trait - implement to provide external operations
pub trait SyscallHandler: Send + Sync {
    /// Execute a syscall and return the result
    fn call(&self, name: &str, args: &serde_json::Value) -> Result<serde_json::Value>;

    /// List available syscalls
    fn available(&self) -> Vec<&str>;
}

/// Default syscall handler with basic file operations
pub struct DefaultSyscallHandler {
    /// Working directory for file operations
    pub working_dir: std::path::PathBuf,
}

impl Default for DefaultSyscallHandler {
    fn default() -> Self {
        Self {
            working_dir: std::env::current_dir().unwrap_or_default(),
        }
    }
}

impl SyscallHandler for DefaultSyscallHandler {
    fn call(&self, name: &str, args: &serde_json::Value) -> Result<serde_json::Value> {
        match name {
            "read_file" => {
                let path = args.get("path")
                    .and_then(|v| v.as_str())
                    .ok_or_else(|| error::invalid_argument("read_file requires 'path' argument"))?;

                let full_path = self.working_dir.join(path);
                match std::fs::read_to_string(&full_path) {
                    Ok(content) => Ok(serde_json::json!({
                        "success": true,
                        "content": content,
                        "path": path
                    })),
                    Err(e) => Ok(serde_json::json!({
                        "success": false,
                        "error": e.to_string(),
                        "path": path
                    })),
                }
            }
            "write_file" => {
                let path = args.get("path")
                    .and_then(|v| v.as_str())
                    .ok_or_else(|| error::invalid_argument("write_file requires 'path' argument"))?;
                let content = args.get("content")
                    .and_then(|v| v.as_str())
                    .ok_or_else(|| error::invalid_argument("write_file requires 'content' argument"))?;

                let full_path = self.working_dir.join(path);
                match std::fs::write(&full_path, content) {
                    Ok(()) => Ok(serde_json::json!({
                        "success": true,
                        "path": path
                    })),
                    Err(e) => Ok(serde_json::json!({
                        "success": false,
                        "error": e.to_string(),
                        "path": path
                    })),
                }
            }
            "list_dir" => {
                let path = args.get("path")
                    .and_then(|v| v.as_str())
                    .unwrap_or(".");

                let full_path = self.working_dir.join(path);
                match std::fs::read_dir(&full_path) {
                    Ok(entries) => {
                        let files: Vec<String> = entries
                            .filter_map(|e| e.ok())
                            .map(|e| e.file_name().to_string_lossy().to_string())
                            .collect();
                        Ok(serde_json::json!({
                            "success": true,
                            "files": files,
                            "path": path
                        }))
                    }
                    Err(e) => Ok(serde_json::json!({
                        "success": false,
                        "error": e.to_string(),
                        "path": path
                    })),
                }
            }
            "exec" => {
                let cmd = args.get("command")
                    .and_then(|v| v.as_str())
                    .ok_or_else(|| error::invalid_argument("exec requires 'command' argument"))?;

                match std::process::Command::new("sh")
                    .arg("-c")
                    .arg(cmd)
                    .current_dir(&self.working_dir)
                    .output()
                {
                    Ok(output) => Ok(serde_json::json!({
                        "success": output.status.success(),
                        "stdout": String::from_utf8_lossy(&output.stdout),
                        "stderr": String::from_utf8_lossy(&output.stderr),
                        "exit_code": output.status.code()
                    })),
                    Err(e) => Ok(serde_json::json!({
                        "success": false,
                        "error": e.to_string()
                    })),
                }
            }
            "grep" => {
                let pattern = args.get("pattern")
                    .and_then(|v| v.as_str())
                    .ok_or_else(|| error::invalid_argument("grep requires 'pattern' argument"))?;
                let path = args.get("path")
                    .and_then(|v| v.as_str())
                    .ok_or_else(|| error::invalid_argument("grep requires 'path' argument"))?;

                let cmd = format!("grep -n '{}' '{}'", pattern, path);
                match std::process::Command::new("sh")
                    .arg("-c")
                    .arg(&cmd)
                    .current_dir(&self.working_dir)
                    .output()
                {
                    Ok(output) => {
                        let matches: Vec<&str> = std::str::from_utf8(&output.stdout)
                            .unwrap_or("")
                            .lines()
                            .collect();
                        Ok(serde_json::json!({
                            "success": true,
                            "matches": matches,
                            "count": matches.len()
                        }))
                    }
                    Err(e) => Ok(serde_json::json!({
                        "success": false,
                        "error": e.to_string()
                    })),
                }
            }
            _ => Err(error::unknown_syscall(name)),
        }
    }

    fn available(&self) -> Vec<&str> {
        vec!["read_file", "write_file", "list_dir", "exec", "grep"]
    }
}

/// The VM Interpreter
pub struct Interpreter<S: SyscallHandler> {
    /// Program being executed
    program: Program,
    /// Program counter
    pc: usize,
    /// Memory (pages)
    memory: Memory,
    /// Stack
    stack: Stack,
    /// Registers
    registers: HashMap<String, serde_json::Value>,
    /// Label to PC mapping
    labels: HashMap<String, usize>,
    /// Syscall handler
    syscall_handler: S,
    /// Execution trace
    trace: Vec<ExecutionStep>,
    /// Step counter
    steps: usize,
    /// Max steps allowed
    max_steps: usize,
    /// Log callback
    log_callback: Option<Box<dyn Fn(LogLevel, &str) + Send + Sync>>,
    /// Pending spawned tasks (task_id -> opcode)
    pending_tasks: HashMap<String, Opcode>,
    /// Current session for persistence
    session: Option<Session>,
    /// Session manager for disk operations (None if initialization failed)
    session_manager: Option<SessionManager>,
}

impl<S: SyscallHandler> Interpreter<S> {
    /// Create a new interpreter for a program
    pub fn new(program: Program, syscall_handler: S) -> Self {
        let mut labels = HashMap::new();

        // Pre-scan for labels
        for (i, op) in program.code.iter().enumerate() {
            if let Opcode::Label { name } = op {
                labels.insert(name.clone(), i);
            }
        }

        Self {
            program,
            pc: 0,
            memory: Memory::new(),
            stack: Stack::new(),
            registers: HashMap::new(),
            labels,
            syscall_handler,
            trace: Vec::new(),
            steps: 0,
            max_steps: MAX_STEPS,
            log_callback: None,
            pending_tasks: HashMap::new(),
            session: None,
            session_manager: SessionManager::new(".llcraft/sessions").ok(),
        }
    }

    /// Set a custom session path
    pub fn with_session_path(mut self, path: impl AsRef<std::path::Path>) -> Self {
        self.session_manager = SessionManager::new(path).ok();
        self
    }

    /// Set session manager directly
    pub fn with_session_manager(mut self, manager: SessionManager) -> Self {
        self.session_manager = Some(manager);
        self
    }

    /// Resume an existing session by ID
    pub fn resume_session(&mut self, session_id: &str) -> Result<()> {
        let manager = self.session_manager.as_ref()
            .ok_or_else(|| error::not_initialized("Session manager not initialized"))?;
        let session = manager.load_session(session_id)?;
        self.session = Some(session);
        Ok(())
    }

    /// Start a new session with a task description
    pub fn start_session(&mut self, task: impl Into<String>) -> Result<String> {
        let manager = self.session_manager.as_ref()
            .ok_or_else(|| error::not_initialized("Session manager not initialized"))?;
        let session = manager.create_session(task)?;
        let id = session.metadata.id.clone();
        self.session = Some(session);
        Ok(id)
    }

    /// Get the current session (if any)
    pub fn session(&self) -> Option<&Session> {
        self.session.as_ref()
    }

    /// Get mutable reference to current session
    pub fn session_mut(&mut self) -> Option<&mut Session> {
        self.session.as_mut()
    }

    /// Set a custom log callback
    pub fn with_log_callback<F>(mut self, callback: F) -> Self
    where
        F: Fn(LogLevel, &str) + Send + Sync + 'static,
    {
        self.log_callback = Some(Box::new(callback));
        self
    }

    /// Set max steps
    pub fn with_max_steps(mut self, max: usize) -> Self {
        self.max_steps = max;
        self
    }

    /// Pre-load a page into memory
    pub fn load_page(&mut self, id: impl Into<String>, content: serde_json::Value) -> Result<()> {
        self.memory.store(id, content)
    }

    /// Get a page from memory
    pub fn get_page(&self, id: &str) -> Option<&serde_json::Value> {
        self.memory.get(id).map(|p| &p.content)
    }

    /// Get all pages as a map of id -> content
    pub fn all_pages(&self) -> HashMap<String, serde_json::Value> {
        self.memory.pages_by_lru()
            .into_iter()
            .map(|p| (p.id.clone(), p.content.clone()))
            .collect()
    }

    /// Resume execution from a saved state
    pub fn resume(state: ExecutionState, syscall_handler: S) -> Self {
        let mut labels = HashMap::new();
        for (i, op) in state.program.code.iter().enumerate() {
            if let Opcode::Label { name } = op {
                labels.insert(name.clone(), i);
            }
        }

        Self {
            program: state.program,
            pc: state.pc,
            memory: state.memory,
            stack: state.stack,
            registers: state.registers,
            labels,
            syscall_handler,
            trace: state.trace,
            steps: state.steps,
            max_steps: MAX_STEPS,
            log_callback: None,
            pending_tasks: HashMap::new(),
            session: None,
            session_manager: SessionManager::new(".llcraft/sessions").ok(),
        }
    }

    /// Provide LLM response and continue execution
    pub fn provide_llm_response(&mut self, response: serde_json::Value, store_to: &str) -> Result<()> {
        self.memory.store(store_to, response)?;
        self.pc += 1; // Move past the INFER/PLAN/REFLECT opcode
        Ok(())
    }

    /// Inject opcodes into the program at the current position (JIT)
    /// The new opcodes are inserted after the current INJECT instruction.
    /// Returns the number of opcodes injected.
    pub fn inject_opcodes(&mut self, opcodes: Vec<Opcode>) -> Result<usize> {
        let count = opcodes.len();
        if count == 0 {
            self.pc += 1;
            return Ok(0);
        }

        // Insert opcodes after current PC
        let insert_pos = self.pc + 1;

        // Update any labels that point past the insertion point
        for (_, label_pc) in self.labels.iter_mut() {
            if *label_pc >= insert_pos {
                *label_pc += count;
            }
        }

        // Scan new opcodes for any labels and add them
        for (i, op) in opcodes.iter().enumerate() {
            if let Opcode::Label { name } = op {
                self.labels.insert(name.clone(), insert_pos + i);
            }
        }

        // Insert the new opcodes
        self.program.code.splice(insert_pos..insert_pos, opcodes);

        // Record what happened
        self.record_step("INJECT", &format!("{} opcodes inserted", count), None);

        // Move past the INJECT instruction
        self.pc += 1;

        Ok(count)
    }

    /// Get current execution state (for serialization)
    pub fn state(&self) -> ExecutionState {
        ExecutionState {
            pc: self.pc,
            program: self.program.clone(),
            memory: self.memory.clone(),
            stack: self.stack.clone(),
            registers: self.registers.clone(),
            trace: self.trace.clone(),
            steps: self.steps,
        }
    }

    /// Get execution trace
    pub fn trace(&self) -> &[ExecutionStep] {
        &self.trace
    }

    /// Run until completion or LLM input needed
    pub fn run(&mut self) -> Result<ExecutionResult> {
        while self.pc < self.program.code.len() {
            if self.steps >= self.max_steps {
                return Ok(ExecutionResult::StepLimitExceeded);
            }

            let opcode = self.program.code[self.pc].clone();
            self.steps += 1;

            match self.execute_opcode(&opcode)? {
                StepResult::Continue => {
                    self.pc += 1;
                }
                StepResult::Jump(target) => {
                    self.pc = self.labels.get(&target)
                        .copied()
                        .ok_or_else(|| error::label_not_found(&target))?;
                }
                StepResult::Complete(result) => {
                    self.record_step("COMPLETE", &format!("{:?}", result), None);
                    return Ok(ExecutionResult::Complete(result));
                }
                StepResult::Fail(error) => {
                    self.record_step("FAIL", &error, Some(error.clone()));
                    return Ok(ExecutionResult::Failed(error));
                }
                StepResult::NeedsLlm(request) => {
                    return Ok(ExecutionResult::NeedsLlm(request));
                }
            }
        }

        // Implicit completion if we run off the end
        Ok(ExecutionResult::Complete(serde_json::json!({
            "status": "completed",
            "message": "Program ended without explicit COMPLETE"
        })))
    }

    fn execute_opcode(&mut self, opcode: &Opcode) -> Result<StepResult> {
        match opcode {
            // Labels are no-ops during execution
            Opcode::Label { name } => {
                self.record_step(&format!("LABEL:{}", name), "entered", None);
                Ok(StepResult::Continue)
            }

            // Logging
            Opcode::Log { level, message } => {
                if let Some(ref cb) = self.log_callback {
                    cb(*level, message);
                }
                self.record_step("LOG", message, None);
                Ok(StepResult::Continue)
            }

            // Memory operations
            Opcode::Load { page_id, .. } => {
                let _ = self.memory.load(page_id)?;
                self.record_step("LOAD", page_id, None);
                Ok(StepResult::Continue)
            }

            Opcode::Store { page_id, data } => {
                self.memory.store(page_id, data.clone())?;
                self.record_step("STORE", page_id, None);
                Ok(StepResult::Continue)
            }

            Opcode::Alloc { label, .. } => {
                let id = self.memory.alloc(label.clone())?;
                self.record_step("ALLOC", &id, None);
                Ok(StepResult::Continue)
            }

            Opcode::Free { page_id } => {
                self.memory.free(page_id)?;
                self.record_step("FREE", page_id, None);
                Ok(StepResult::Continue)
            }

            Opcode::Copy { src, dst, .. } => {
                self.memory.copy(src, dst)?;
                self.record_step("COPY", &format!("{} -> {}", src, dst), None);
                Ok(StepResult::Continue)
            }

            // Stack operations
            Opcode::Push { value } => {
                self.stack.push(value.clone())?;
                self.record_step("PUSH", "value pushed", None);
                Ok(StepResult::Continue)
            }

            Opcode::PushPage { page_id } => {
                let content = self.memory.load(page_id)?.clone();
                self.stack.push(content)?;
                self.record_step("PUSH_PAGE", page_id, None);
                Ok(StepResult::Continue)
            }

            Opcode::Pop => {
                self.stack.pop()?;
                self.record_step("POP", "value popped", None);
                Ok(StepResult::Continue)
            }

            Opcode::PopTo { store_to } => {
                let value = self.stack.pop()?;
                self.memory.store(store_to, value)?;
                self.record_step("POP_TO", store_to, None);
                Ok(StepResult::Continue)
            }

            Opcode::Peek { store_to } => {
                let value = self.stack.peek()?.clone();
                self.memory.store(store_to, value)?;
                self.record_step("PEEK", store_to, None);
                Ok(StepResult::Continue)
            }

            Opcode::PeekAt { depth, store_to } => {
                let value = self.stack.peek_at(*depth)?.clone();
                self.memory.store(store_to, value)?;
                self.record_step("PEEK_AT", &format!("{} -> {}", depth, store_to), None);
                Ok(StepResult::Continue)
            }

            Opcode::Dup => {
                self.stack.dup()?;
                self.record_step("DUP", "duplicated", None);
                Ok(StepResult::Continue)
            }

            Opcode::DupN { n } => {
                self.stack.dup_n(*n)?;
                self.record_step("DUP_N", &format!("{}", n), None);
                Ok(StepResult::Continue)
            }

            Opcode::Swap => {
                self.stack.swap()?;
                self.record_step("SWAP", "swapped", None);
                Ok(StepResult::Continue)
            }

            Opcode::SwapN { n } => {
                self.stack.swap_n(*n)?;
                self.record_step("SWAP_N", &format!("{}", n), None);
                Ok(StepResult::Continue)
            }

            Opcode::Rot { n } => {
                self.stack.rot(*n)?;
                self.record_step("ROT", &format!("{}", n), None);
                Ok(StepResult::Continue)
            }

            Opcode::Drop { n } => {
                for _ in 0..*n {
                    self.stack.pop()?;
                }
                self.record_step("DROP", &format!("{}", n), None);
                Ok(StepResult::Continue)
            }

            Opcode::Depth { store_to } => {
                let depth = self.stack.len();
                self.memory.store(store_to, serde_json::json!(depth))?;
                self.record_step("DEPTH", &format!("{}", depth), None);
                Ok(StepResult::Continue)
            }

            Opcode::Clear => {
                self.stack.clear();
                self.record_step("CLEAR", "stack cleared", None);
                Ok(StepResult::Continue)
            }

            // Control flow
            Opcode::Jump { target } => {
                self.record_step("JUMP", target, None);
                Ok(StepResult::Jump(target.clone()))
            }

            Opcode::Branch { condition, if_true, if_false } => {
                let result = self.evaluate_condition(condition)?;
                let target = if result { if_true } else { if_false };
                self.record_step("BRANCH", &format!("{} -> {}", condition, target), None);
                Ok(StepResult::Jump(target.clone()))
            }

            Opcode::Complete { result } => {
                Ok(StepResult::Complete(result.clone()))
            }

            Opcode::Fail { error } => {
                Ok(StepResult::Fail(error.clone()))
            }

            // Tool operations - explicit file/exec tools
            Opcode::ReadFile { path, store_to } => {
                let result = self.syscall_handler.call("read_file", &serde_json::json!({"path": path}))?;
                self.memory.store(store_to, result)?;
                self.record_step("READ_FILE", path, None);
                Ok(StepResult::Continue)
            }

            Opcode::WriteFile { path, content, store_to } => {
                let result = self.syscall_handler.call("write_file", &serde_json::json!({
                    "path": path,
                    "content": content
                }))?;
                if let Some(page_id) = store_to {
                    self.memory.store(page_id, result)?;
                }
                self.record_step("WRITE_FILE", path, None);
                Ok(StepResult::Continue)
            }

            Opcode::ListDir { path, store_to } => {
                let result = self.syscall_handler.call("list_dir", &serde_json::json!({"path": path}))?;
                self.memory.store(store_to, result)?;
                self.record_step("LIST_DIR", path, None);
                Ok(StepResult::Continue)
            }

            Opcode::Exec { command, store_to } => {
                let result = self.syscall_handler.call("exec", &serde_json::json!({"command": command}))?;
                self.memory.store(store_to, result)?;
                self.record_step("EXEC", command, None);
                Ok(StepResult::Continue)
            }

            Opcode::Grep { pattern, path, store_to } => {
                let result = self.syscall_handler.call("grep", &serde_json::json!({
                    "pattern": pattern,
                    "path": path
                }))?;
                self.memory.store(store_to, result)?;
                self.record_step("GREP", &format!("{} in {}", pattern, path), None);
                Ok(StepResult::Continue)
            }

            // LLM operations - these pause execution
            Opcode::Infer { prompt, context, store_to, .. } => {
                self.record_step("INFER", "awaiting LLM response", None);
                Ok(StepResult::NeedsLlm(LlmRequest {
                    request_type: LlmRequestType::Infer,
                    prompt: prompt.clone(),
                    context_pages: context.clone(),
                    store_to: store_to.clone(),
                    execution_state: self.state(),
                }))
            }

            Opcode::Plan { goal, context, store_to } => {
                self.record_step("PLAN", "awaiting LLM response", None);
                Ok(StepResult::NeedsLlm(LlmRequest {
                    request_type: LlmRequestType::Plan,
                    prompt: goal.clone(),
                    context_pages: context.clone(),
                    store_to: store_to.clone(),
                    execution_state: self.state(),
                }))
            }

            Opcode::Reflect { question, include_trace, store_to } => {
                self.record_step("REFLECT", "awaiting LLM response", None);
                Ok(StepResult::NeedsLlm(LlmRequest {
                    request_type: LlmRequestType::Reflect { include_trace: *include_trace },
                    prompt: question.clone(),
                    context_pages: vec![],
                    store_to: store_to.clone(),
                    execution_state: self.state(),
                }))
            }

            // JIT code injection - LLM generates opcodes at runtime
            Opcode::Inject { goal, context, include_trace, include_memory } => {
                self.record_step("INJECT", "awaiting LLM to generate opcodes", None);
                Ok(StepResult::NeedsLlm(LlmRequest {
                    request_type: LlmRequestType::Inject {
                        include_trace: *include_trace,
                        include_memory: *include_memory,
                    },
                    prompt: goal.clone(),
                    context_pages: context.clone(),
                    store_to: String::new(), // Not used for INJECT
                    execution_state: self.state(),
                }))
            }

            // Summarize - uses LLM to compress
            Opcode::Summarize { pages, store_to, target_tokens } => {
                // Gather content from pages
                let mut content = String::new();
                for page_id in pages {
                    if let Some(page) = self.memory.get(page_id) {
                        content.push_str(&format!("## {}\n{}\n\n", page_id, page.content));
                    }
                }

                let prompt = if let Some(tokens) = target_tokens {
                    format!("Summarize the following content to approximately {} tokens:\n\n{}", tokens, content)
                } else {
                    format!("Summarize the following content concisely:\n\n{}", content)
                };

                self.record_step("SUMMARIZE", "awaiting LLM response", None);
                Ok(StepResult::NeedsLlm(LlmRequest {
                    request_type: LlmRequestType::Infer,
                    prompt,
                    context_pages: vec![],
                    store_to: store_to.clone(),
                    execution_state: self.state(),
                }))
            }

            // Merge pages - done locally
            Opcode::Merge { pages, store_to, separator } => {
                let sep = separator.as_deref().unwrap_or("\n\n");
                let mut parts = Vec::new();
                for page_id in pages {
                    if let Some(page) = self.memory.get(page_id) {
                        parts.push(page.content.to_string());
                    }
                }
                let merged = parts.join(sep);
                self.memory.store(store_to, serde_json::json!(merged))?;
                self.record_step("MERGE", &format!("{} pages -> {}", pages.len(), store_to), None);
                Ok(StepResult::Continue)
            }

            // Chunk - split a page into smaller pieces
            Opcode::Chunk { source, chunk_size, prefix } => {
                let content = self.memory.load(source)?.to_string();
                let prefix = prefix.as_deref().unwrap_or("chunk");
                let chunks: Vec<&str> = content.as_bytes()
                    .chunks(*chunk_size)
                    .map(|c| std::str::from_utf8(c).unwrap_or(""))
                    .collect();

                for (i, chunk) in chunks.iter().enumerate() {
                    let page_id = format!("{}_{}", prefix, i);
                    self.memory.store(&page_id, serde_json::json!(chunk))?;
                }
                self.record_step("CHUNK", &format!("{} -> {} chunks", source, chunks.len()), None);
                Ok(StepResult::Continue)
            }

            // Register operations
            Opcode::SetReg { reg, value } => {
                let reg_name = format!("{:?}", reg).to_lowercase();
                self.registers.insert(reg_name.clone(), value.clone());
                self.record_step("SET_REG", &reg_name, None);
                Ok(StepResult::Continue)
            }

            Opcode::GetReg { reg, store_to } => {
                let reg_name = format!("{:?}", reg).to_lowercase();
                let value = self.registers.get(&reg_name).cloned().unwrap_or(serde_json::Value::Null);
                self.memory.store(store_to, value)?;
                self.record_step("GET_REG", &format!("{} -> {}", reg_name, store_to), None);
                Ok(StepResult::Continue)
            }

            // Checkpoint/Rollback - simplified implementation
            Opcode::Checkpoint { name } => {
                // Store current state as a checkpoint
                let state = self.state();
                self.registers.insert(
                    format!("__checkpoint_{}", name),
                    serde_json::to_value(&state).unwrap_or_default(),
                );
                self.record_step("CHECKPOINT", name, None);
                Ok(StepResult::Continue)
            }

            Opcode::Rollback { name } => {
                // For now, just log - full rollback would need more infrastructure
                self.record_step("ROLLBACK", name, None);
                Ok(StepResult::Continue)
            }

            Opcode::Assert { condition, message } => {
                if !self.evaluate_condition(condition)? {
                    return Ok(StepResult::Fail(message.clone()));
                }
                self.record_step("ASSERT", condition, None);
                Ok(StepResult::Continue)
            }

            Opcode::Nop => {
                Ok(StepResult::Continue)
            }

            // These are not yet implemented
            Opcode::Yield => {
                self.record_step("YIELD", "yielded", None);
                Ok(StepResult::Continue)
            }

            Opcode::Call { program_id, .. } => {
                self.record_step("CALL", program_id, Some("Not implemented".to_string()));
                Err(error::not_implemented("CALL"))
            }

            Opcode::Return { .. } => {
                self.record_step("RETURN", "", Some("Not implemented".to_string()));
                Err(error::not_implemented("RETURN"))
            }

            Opcode::Loop { .. } => {
                self.record_step("LOOP", "", Some("Not implemented".to_string()));
                Err(error::not_implemented("LOOP"))
            }

            Opcode::Spawn { task_id, task } => {
                // Record spawned task for later parallel execution
                self.pending_tasks.insert(task_id.clone(), (**task).clone());
                self.record_step("SPAWN", &task_id, None);
                Ok(StepResult::Continue)
            }

            Opcode::Join { task_ids, store_to } => {
                // Collect results from spawned tasks (or all if empty)
                let ids: Vec<String> = if task_ids.is_empty() {
                    self.pending_tasks.keys().cloned().collect()
                } else {
                    task_ids.clone()
                };

                // For now, execute tasks sequentially (async runtime would parallelize)
                let mut results = serde_json::Map::new();
                let mut all_success = true;

                for id in &ids {
                    if let Some(task) = self.pending_tasks.remove(id) {
                        // Execute the task opcode
                        if let Err(e) = self.execute_opcode(&task) {
                            results.insert(id.clone(), serde_json::json!({
                                "success": false,
                                "error": e.to_string()
                            }));
                            all_success = false;
                        } else {
                            // Task completed successfully
                            results.insert(id.clone(), serde_json::json!({
                                "success": true,
                                "completed": true
                            }));
                        }
                    }
                }

                // Add top-level success indicator
                results.insert("success".to_string(), serde_json::json!(all_success));

                self.memory.store(store_to, serde_json::Value::Object(results))?;
                self.record_step("JOIN", &store_to, None);
                Ok(StepResult::Continue)
            }

            Opcode::Parallel { branches, store_to } => {
                // Execute all branches (sequentially for now, async runtime would parallelize)
                let mut results = serde_json::Map::new();
                let mut all_success = true;

                for branch in branches {
                    let mut branch_ok = true;
                    for op in &branch.ops {
                        if let Err(e) = self.execute_opcode(op) {
                            results.insert(branch.id.clone(), serde_json::json!({
                                "success": false,
                                "error": e.to_string()
                            }));
                            branch_ok = false;
                            all_success = false;
                            break;
                        }
                    }
                    if branch_ok {
                        results.insert(branch.id.clone(), serde_json::json!({
                            "success": true
                        }));
                    }
                }

                // Add top-level success indicator
                results.insert("success".to_string(), serde_json::json!(all_success));

                self.memory.store(store_to, serde_json::Value::Object(results))?;
                self.record_step("PARALLEL", &store_to, None);
                Ok(StepResult::Continue)
            }

            // =========================================================================
            // SESSION OPERATIONS
            // =========================================================================

            Opcode::LoadSession { session_id, store_to } => {
                let manager = match &self.session_manager {
                    Some(m) => m,
                    None => {
                        self.memory.store(store_to, serde_json::json!({
                            "success": false,
                            "error": "Session manager not available"
                        }))?;
                        return Ok(StepResult::Continue);
                    }
                };

                match session_id {
                    Some(id) => {
                        // Load specific session
                        match manager.load_session(id) {
                            Ok(session) => {
                                let result = serde_json::json!({
                                    "success": true,
                                    "session_id": session.metadata.id,
                                    "task": session.metadata.task,
                                    "page_index": session.get_index_json(),
                                    "trace_summary": session.get_trace_summary(),
                                    "status": format!("{:?}", session.metadata.status),
                                    "total_steps": session.metadata.total_steps,
                                    "llm_calls": session.metadata.llm_calls,
                                });
                                self.memory.store(store_to, result)?;
                                self.session = Some(session);
                                self.record_step("LOAD_SESSION", id, None);
                            }
                            Err(e) => {
                                self.memory.store(store_to, serde_json::json!({
                                    "success": false,
                                    "error": e.to_string()
                                }))?;
                                self.record_step("LOAD_SESSION", id, Some(e.to_string()));
                            }
                        }
                    }
                    None => {
                        // List available sessions (just IDs, metadata needs separate load)
                        match manager.list_sessions() {
                            Ok(session_ids) => {
                                self.memory.store(store_to, serde_json::json!({
                                    "success": true,
                                    "sessions": session_ids,
                                    "count": session_ids.len()
                                }))?;
                                self.record_step("LOAD_SESSION", "listed sessions", None);
                            }
                            Err(e) => {
                                self.memory.store(store_to, serde_json::json!({
                                    "success": false,
                                    "sessions": [],
                                    "error": e.to_string()
                                }))?;
                            }
                        }
                    }
                }
                Ok(StepResult::Continue)
            }

            Opcode::SaveSession { session_id, store_to } => {
                let result = if let (Some(ref mut session), Some(ref manager)) = (&mut self.session, &self.session_manager) {
                    if let Some(id) = session_id {
                        session.metadata.id = id.clone();
                    }

                    // Update session metrics
                    session.metadata.total_steps = self.steps;
                    session.touch();

                    match manager.save_session(session) {
                        Ok(()) => serde_json::json!({
                            "success": true,
                            "session_id": session.metadata.id,
                        }),
                        Err(e) => serde_json::json!({
                            "success": false,
                            "error": e.to_string()
                        })
                    }
                } else if self.session.is_none() {
                    serde_json::json!({
                        "success": false,
                        "error": "No active session"
                    })
                } else {
                    serde_json::json!({
                        "success": false,
                        "error": "Session manager not available"
                    })
                };

                if let Some(ref page_id) = store_to {
                    self.memory.store(page_id, result)?;
                }
                self.record_step("SAVE_SESSION", "saved", None);
                Ok(StepResult::Continue)
            }

            Opcode::LoadPage { page_id, store_to } => {
                let target = store_to.as_deref().unwrap_or(&page_id);

                let load_result = if let (Some(ref mut session), Some(ref manager)) = (&mut self.session, &self.session_manager) {
                    match manager.load_page(&session.metadata.id, &page_id) {
                        Ok(page) => {
                            session.set_page_loaded(&page_id, true);
                            Ok(page)
                        }
                        Err(e) => Err(e)
                    }
                } else {
                    Err(error::not_initialized("No active session or manager"))
                };

                match load_result {
                    Ok(page) => {
                        // Store the page content under the target name
                        // Add success flag for branching
                        let mut content = page.content.clone();
                        if let serde_json::Value::Object(ref mut obj) = content {
                            obj.insert("success".to_string(), serde_json::Value::Bool(true));
                        }
                        self.memory.store(target, content)?;
                        self.record_step("LOAD_PAGE", &format!("{} -> {}", page_id, target), None);
                    }
                    Err(e) => {
                        // Try loading from current memory as fallback
                        if let Some(existing_page) = self.memory.get(&page_id) {
                            let content = existing_page.content.clone();
                            self.memory.store(target, content)?;
                            self.record_step("LOAD_PAGE", &format!("{} (from memory)", page_id), None);
                        } else {
                            self.memory.store(target, serde_json::json!({
                                "success": false,
                                "error": e.to_string()
                            }))?;
                            self.record_step("LOAD_PAGE", &page_id, Some(e.to_string()));
                        }
                    }
                }
                Ok(StepResult::Continue)
            }

            Opcode::SavePage { page_id, summary, content_type: _ } => {
                if let (Some(ref mut session), Some(ref manager)) = (&mut self.session, &self.session_manager) {
                    // Get page from memory
                    if let Some(page) = self.memory.get(&page_id) {
                        // Index the page in session
                        session.index_page(page, summary.clone());

                        // Save page to disk
                        match manager.save_page(&session.metadata.id, page) {
                            Ok(()) => {
                                self.record_step("SAVE_PAGE", &page_id, None);
                            }
                            Err(e) => {
                                self.record_step("SAVE_PAGE", &page_id, Some(e.to_string()));
                            }
                        }
                    } else {
                        self.record_step("SAVE_PAGE", &page_id, Some("Page not found in memory".to_string()));
                    }
                } else {
                    self.record_step("SAVE_PAGE", &page_id, Some("No active session or manager".to_string()));
                }
                Ok(StepResult::Continue)
            }

            Opcode::EvictPage { page_id } => {
                // Remove from active memory but keep in session index
                self.memory.free(&page_id)?;

                if let Some(ref mut session) = self.session {
                    session.set_page_loaded(&page_id, false);
                }

                self.record_step("EVICT_PAGE", &page_id, None);
                Ok(StepResult::Continue)
            }

            Opcode::GetPageIndex { store_to } => {
                let index = if let Some(ref session) = self.session {
                    serde_json::json!({
                        "success": true,
                        "pages": session.get_index_json(),
                        "loaded": session.loaded_page_ids(),
                    })
                } else {
                    // No session - return current memory pages
                    let pages: Vec<serde_json::Value> = self.memory.pages_by_lru()
                        .iter()
                        .map(|p| serde_json::json!({
                            "id": p.id,
                            "tokens": p.content.to_string().len() / 4,
                            "loaded": true,
                        }))
                        .collect();
                    serde_json::json!({
                        "success": true,
                        "pages": pages,
                        "note": "No active session - showing memory pages"
                    })
                };
                self.memory.store(store_to, index)?;
                self.record_step("GET_PAGE_INDEX", store_to, None);
                Ok(StepResult::Continue)
            }

            Opcode::SetSessionStatus { status, message } => {
                if let Some(ref mut session) = self.session {
                    let new_status = match status.to_lowercase().as_str() {
                        "active" => SessionStatus::Active,
                        "completed" => SessionStatus::Completed,
                        "failed" => SessionStatus::Failed,
                        "abandoned" => SessionStatus::Abandoned,
                        _ => SessionStatus::Active,
                    };
                    session.metadata.status = new_status;

                    // Store message as active memory entry if provided
                    if let Some(msg) = message {
                        let page = crate::memory::MemoryPage::new("_status_message", serde_json::json!(msg));
                        let _ = session.active_memory.store_page(page);
                    }

                    self.record_step("SET_SESSION_STATUS", &status, None);
                } else {
                    self.record_step("SET_SESSION_STATUS", &status, Some("No active session".to_string()));
                }
                Ok(StepResult::Continue)
            }

            Opcode::GetTraceSummary { store_to, max_entries } => {
                let max = max_entries.unwrap_or(20);
                let summary = if let Some(ref session) = self.session {
                    // Get trace and potentially truncate
                    let trace = session.get_trace_summary();
                    let lines: Vec<&str> = trace.lines().collect();
                    let truncated: String = lines.iter()
                        .rev()
                        .take(max)
                        .rev()
                        .cloned()
                        .collect::<Vec<_>>()
                        .join("\n");
                    serde_json::json!({
                        "success": true,
                        "trace": truncated,
                        "total_steps": session.metadata.total_steps,
                    })
                } else {
                    // No session - use execution trace
                    let trace_entries: Vec<serde_json::Value> = self.trace.iter()
                        .rev()
                        .take(max)
                        .map(|e| serde_json::json!({
                            "step": e.step,
                            "opcode": e.opcode,
                            "result": e.result,
                            "error": e.error,
                        }))
                        .collect();
                    serde_json::json!({
                        "success": true,
                        "trace": trace_entries,
                        "total_steps": self.steps,
                    })
                };
                self.memory.store(store_to, summary)?;
                self.record_step("GET_TRACE_SUMMARY", store_to, None);
                Ok(StepResult::Continue)
            }

            // Batched inference - run multiple LLM queries (returns as pending)
            // The actual execution happens in the agent loop which runs them concurrently
            Opcode::InferBatch { prompts, context, store_prefix, store_combined, params } => {
                // Build context from pages
                let ctx: Vec<serde_json::Value> = context.iter()
                    .filter_map(|name| self.memory.get(name))
                    .map(|p| p.content.clone())
                    .collect();

                // Create a batched request that the agent loop will handle
                self.record_step(
                    "INFER_BATCH",
                    &format!("{} prompts  {}_*", prompts.len(), store_prefix),
                    None,
                );

                // Return NeedsLlm with batch info embedded in request_type
                // The agent loop is responsible for running these concurrently
                Ok(StepResult::NeedsLlm(LlmRequest {
                    request_type: LlmRequestType::InferBatch {
                        prompts: prompts.clone(),
                        context: ctx,
                        store_prefix: store_prefix.clone(),
                        store_combined: store_combined.clone(),
                        params: params.clone(),
                    },
                    prompt: format!("INFER_BATCH: {} prompts", prompts.len()),
                    context_pages: context.clone(),
                    store_to: store_prefix.clone(),
                    execution_state: self.state(),
                }))
            }

            Opcode::Send { .. } | Opcode::Recv { .. } | Opcode::Wait { .. } => {
                Err(error::not_implemented("Process operations"))
            }
        }
    }

    /// Evaluate a condition string
    fn evaluate_condition(&self, condition: &str) -> Result<bool> {
        // Simple condition evaluation
        // Supports: page.field, page.success, page.error, comparisons

        let condition = condition.trim();

        // Check for null/empty comparisons
        if condition.contains("== null") || condition.contains("!= null") {
            let parts: Vec<&str> = condition.split(|c| c == '=' || c == '!').collect();
            if let Some(path) = parts.first() {
                let path = path.trim();
                let value = self.resolve_path(path);
                let is_null = value.is_none() || value == Some(&serde_json::Value::Null);
                return Ok(if condition.contains("!= null") { !is_null } else { is_null });
            }
        }

        // Check for .error or .success
        if condition.ends_with(".error") {
            let page_id = condition.trim_end_matches(".error");
            if let Some(page) = self.memory.get(page_id) {
                let has_error = page.content.get("error").is_some()
                    || page.content.get("success") == Some(&serde_json::json!(false));
                return Ok(has_error);
            }
            return Ok(true); // Page not found = error
        }

        if condition.ends_with(".success") {
            let page_id = condition.trim_end_matches(".success");
            if let Some(page) = self.memory.get(page_id) {
                let success = page.content.get("success") == Some(&serde_json::json!(true));
                return Ok(success);
            }
            return Ok(false);
        }

        // Check for truthiness of a path
        if let Some(value) = self.resolve_path(condition) {
            return Ok(is_truthy(value));
        }

        // Default to false for unknown conditions
        Ok(false)
    }

    /// Resolve a path like "page.field.subfield" to a value
    fn resolve_path(&self, path: &str) -> Option<&serde_json::Value> {
        let parts: Vec<&str> = path.split('.').collect();
        if parts.is_empty() {
            return None;
        }

        let page = self.memory.get(parts[0])?;
        let mut current = &page.content;

        for part in &parts[1..] {
            current = current.get(part)?;
        }

        Some(current)
    }

    fn record_step(&mut self, opcode: &str, result: &str, error: Option<String>) {
        let step_num = self.trace.len();

        // Record to execution trace
        self.trace.push(ExecutionStep {
            step: step_num,
            opcode: opcode.to_string(),
            result: result.to_string(),
            error: error.clone(),
        });

        // Also record to session if active
        if let Some(ref mut session) = self.session {
            session.add_trace(step_num, opcode, result, error.is_some());
        }
    }
}

/// Result of executing a single opcode
enum StepResult {
    /// Continue to next opcode
    Continue,
    /// Jump to a label
    Jump(String),
    /// Program completed
    Complete(serde_json::Value),
    /// Program failed
    Fail(String),
    /// Needs LLM input
    NeedsLlm(LlmRequest),
}

/// Check if a JSON value is "truthy"
fn is_truthy(value: &serde_json::Value) -> bool {
    match value {
        serde_json::Value::Null => false,
        serde_json::Value::Bool(b) => *b,
        serde_json::Value::Number(n) => n.as_f64().map(|f| f != 0.0).unwrap_or(false),
        serde_json::Value::String(s) => !s.is_empty(),
        serde_json::Value::Array(a) => !a.is_empty(),
        serde_json::Value::Object(o) => !o.is_empty(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_program() {
        let program = Program::new(
            "test",
            "Test Program",
            vec![
                Opcode::Label { name: "entry".to_string() },
                Opcode::Store {
                    page_id: "result".to_string(),
                    data: serde_json::json!({"message": "hello"})
                },
                Opcode::Complete {
                    result: serde_json::json!({"page": "result"})
                },
            ],
        );

        let mut interp = Interpreter::new(program, DefaultSyscallHandler::default());
        let result = interp.run().unwrap();

        match result {
            ExecutionResult::Complete(v) => {
                assert_eq!(v, serde_json::json!({"page": "result"}));
            }
            _ => panic!("Expected Complete"),
        }
    }

    #[test]
    fn test_list_dir() {
        let program = Program::new(
            "test_list_dir",
            "Test ListDir",
            vec![
                Opcode::ListDir {
                    path: ".".to_string(),
                    store_to: "files".to_string(),
                },
                Opcode::Complete {
                    result: serde_json::json!({"files_page": "files"}),
                },
            ],
        );

        let mut interp = Interpreter::new(program, DefaultSyscallHandler::default());
        let result = interp.run().unwrap();

        match result {
            ExecutionResult::Complete(_) => {}
            _ => panic!("Expected Complete"),
        }

        // Check that the files page was created
        assert!(interp.get_page("files").is_some());
    }

    #[test]
    fn test_branch() {
        let program = Program::new(
            "test_branch",
            "Test Branch",
            vec![
                Opcode::Store {
                    page_id: "test".to_string(),
                    data: serde_json::json!({"success": true}),
                },
                Opcode::Branch {
                    condition: "test.success".to_string(),
                    if_true: "success".to_string(),
                    if_false: "failure".to_string(),
                },
                Opcode::Label { name: "success".to_string() },
                Opcode::Complete {
                    result: serde_json::json!({"result": "success"}),
                },
                Opcode::Label { name: "failure".to_string() },
                Opcode::Fail { error: "should not reach here".to_string() },
            ],
        );

        let mut interp = Interpreter::new(program, DefaultSyscallHandler::default());
        let result = interp.run().unwrap();

        match result {
            ExecutionResult::Complete(v) => {
                assert_eq!(v, serde_json::json!({"result": "success"}));
            }
            _ => panic!("Expected Complete"),
        }
    }

    #[test]
    fn test_spawn_join() {
        // Test SPAWN and JOIN for parallel execution
        let program = Program::new(
            "test_spawn_join",
            "Test Spawn/Join",
            vec![
                Opcode::Label { name: "entry".to_string() },
                // Spawn two LIST_DIR tasks
                Opcode::Spawn {
                    task_id: "t1".to_string(),
                    task: Box::new(Opcode::ListDir {
                        path: "src".to_string(),
                        store_to: "src_files".to_string(),
                    }),
                },
                Opcode::Spawn {
                    task_id: "t2".to_string(),
                    task: Box::new(Opcode::Store {
                        page_id: "store_test".to_string(),
                        data: serde_json::json!({"value": 42}),
                    }),
                },
                // Join and wait for both tasks
                Opcode::Join {
                    task_ids: vec!["t1".to_string(), "t2".to_string()],
                    store_to: "join_results".to_string(),
                },
                // Complete with the results
                Opcode::Complete {
                    result: serde_json::json!({"done": true}),
                },
            ],
        );

        let mut interp = Interpreter::new(program, DefaultSyscallHandler::default());
        let result = interp.run().unwrap();

        match result {
            ExecutionResult::Complete(v) => {
                assert_eq!(v, serde_json::json!({"done": true}));
            }
            _ => panic!("Expected Complete, got {:?}", result),
        }

        // Verify the spawned tasks executed and stored to pages
        let src_files = interp.get_page("src_files");
        assert!(src_files.is_some(), "src_files page should exist");
        let src_content = src_files.unwrap();
        assert_eq!(src_content.get("success"), Some(&serde_json::json!(true)));

        let store_test = interp.get_page("store_test");
        assert!(store_test.is_some(), "store_test page should exist");
        assert_eq!(store_test.unwrap().get("value"), Some(&serde_json::json!(42)));

        // Join results should have completion status for both tasks
        let join_results = interp.get_page("join_results");
        assert!(join_results.is_some(), "join_results page should exist");
        let join_content = join_results.unwrap();
        assert!(join_content.get("t1").is_some());
        assert!(join_content.get("t2").is_some());
    }

    #[test]
    fn test_parallel_branches() {
        // Test PARALLEL with multiple branches
        let program = Program::new(
            "test_parallel",
            "Test Parallel",
            vec![
                Opcode::Parallel {
                    branches: vec![
                        crate::opcode::ParallelBranch {
                            id: "b1".to_string(),
                            ops: vec![
                                Opcode::Store {
                                    page_id: "page_a".to_string(),
                                    data: serde_json::json!({"a": 1}),
                                },
                            ],
                        },
                        crate::opcode::ParallelBranch {
                            id: "b2".to_string(),
                            ops: vec![
                                Opcode::Store {
                                    page_id: "page_b".to_string(),
                                    data: serde_json::json!({"b": 2}),
                                },
                            ],
                        },
                    ],
                    store_to: "parallel_results".to_string(),
                },
                Opcode::Complete {
                    result: serde_json::json!({"done": true}),
                },
            ],
        );

        let mut interp = Interpreter::new(program, DefaultSyscallHandler::default());
        let result = interp.run().unwrap();

        match result {
            ExecutionResult::Complete(_) => {}
            _ => panic!("Expected Complete"),
        }

        // Both branch pages should exist
        assert!(interp.get_page("page_a").is_some());
        assert!(interp.get_page("page_b").is_some());

        // Parallel results should have success for both branches
        let parallel_results = interp.get_page("parallel_results").unwrap();
        assert_eq!(parallel_results.get("b1").unwrap().get("success"), Some(&serde_json::json!(true)));
        assert_eq!(parallel_results.get("b2").unwrap().get("success"), Some(&serde_json::json!(true)));
    }
}
